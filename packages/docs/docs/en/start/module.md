# Custom Configurable Modules

The official preset configuration modules are based on categories derived from `three.js`. However, for a variety of
project needs:

- Officially categorized modules can be cumbersome and complex.
- Integrating business logic can be challenging.

In such cases, there's a demand for developing custom configurable modules based on current project business
experiences, aiming to better align with the current business ecosystem and improve construction efficiency.

## Principles of Configurability

Before introducing custom configurable construction, let's briefly go over the principles of configurability:

- **Reactive Configuration**: Configurations generated by `generateConfig` internally create observer objects for
  configuration objects. These are then exposed through objects proxied by `proxy`, which intercept all operations on
  the objects.

- **Operation Interception and Notification**: When manipulating properties of `proxy` objects, internal observers will
  format all related operations like `add`, `set`, `delete` into notifications and emit them.

- **Rule Translation and Execution**: All emitted notifications are processed by `rule` functions. The `rule` processes
  these rules, determining which notifications can be ignored and which require `compiler` actions.

- **Compiler and Processor Invocation**: The compiler `compiler` is a stateful object with its memory space, generally
  specifying macro operations and scheduling. However, specific operations are executed by processors `processor`
  assigned to each `config`.

![Configuration Middleware Principle](/image/start/middleware-principle.png)

## Configurable Module Options

Configurable module options are the options object a module needs when handed over to the engine. The engine uses these
options to register and extend the module.

```ts
export interface ModuleOptions<C extends Compiler<any, any>> {
    type: string; // Module type
    compiler: new () => C; // Compiler class for this module
    rule: Rule<C>; // Module rule function
    processors: Processor<any, any, any, C>[]; // Array of processors under the module
    object?: boolean; // Whether the corresponding 3D object of this module will act as a 3D body
    extend?: <E extends EngineSupport>(engine: E) => void; // Extension method for the engine by the module
    lifeOrder?: number; // Life cycle position of the module
    // @Experimental - Experimental properties
    expand?: {
        // How installing this module will extend other modules
        processors: string[] | RegExp;
        command: ProcessorCommands<any, any, any, any>;
    }[];
}
```

## Defining Configuration

Let's walk through the entire custom configuration process using a case study. For example, suppose we have the
following requirements:

- A wooden board module is needed.
- The scene should allow adding and removing wooden boards.
- The wooden boards should support setting their length, width, and height.
- The wooden boards should be able to set their position and rotation.
- The wooden boards should also support different styles, such as: Jet Black, Brown Yellow, and Cream White.

Based on these requirements, we can define the configuration for the wooden board as follows:

```ts
// config.ts
import {SymbolConfig, getSymbolConfig} from "@vis-three/middleware";

export interface BoardConfig extends SymbolConfig {
    parent: string;
    width: number;
    height: number;
    depth: number;
    position: {
        x: number;
        y: number;
        z: number;
    };
    rotation: {
        x: number;
        y: number;
        z: number;
    };
    style: "elegant-black" | "light-brown" | "milky-white";
}

export const getBoardConfig = function: BoardConfig {
    return {
        ...getSymbolConfig(),
        parent: '',
        width: 10,
        height: 10,
        depth: 10,
        position: {
            x: 0,
            y: 0,
            z: 0,
        },
        rotation: {
            x: 0,
            y: 0,
            z: 0,
        },
        style: "light-brown"
    }
}
```

:::tip

- The configuration we define must extend the `symbolConfig` interface, as `symbolConfig` defines the common properties
  for the entire configuration. If you are using `js`, remember to call and merge the returned value
  from `getSymbolConfig`.

- When writing the method to generate the configuration, such as the `getBoardConfig` method mentioned above, the
  property values of the object returned by this method represent the default values for the configuration. We can
  adjust our defaults based on this feature.

- A module can define multiple configurations.
  :::

## Defining the Compiler

The compiler serves as the storage and scheduling space for the specific objects of our module. In most cases, you can
simply extend the default compiler. However, if the current module requires unified operation methods, you can also
extend the methods within the compiler as needed.

```ts
// compiler.ts
import {Mesh} from "three";
import {CompileNotice, Compiler} from "@vis-three/middleware";

export class BoardCompiler extends Compiler<BoardConfig, Mesh> {
    constructor() {
        super();
    }
}
```

:::tip
If you are using `ts`, you need to specify two generics: one for all the **configuration objects** that the compiler
needs to handle, and one for the **actual real objects** corresponding to the configuration objects.
:::

## Defining Conversion Rules

Conversion rules handle the notifications generated when manipulating reactive configuration objects. By default, you
can use the default rule functions directly. For specific conversions, you can extend the functions internally as
needed.

```ts
// rule.ts
import {ProxyNotice, Rule} from "@vis-three/middleware";
import {BoardCompiler} from "./Compiler";

// Define a conversion rule for the BoardCompiler
export const BoardRule: Rule<BoardCompiler> = function (
    notice: ProxyNotice,
    compiler: BoardCompiler
) {
    // Skip parent properties because they are influenced by operations on parent objects.
    // Therefore, they can be ignored in this compilation.
    if (notice.key === "parent") {
        return;
    }

    Rule(notice, compiler);
};
```

:::tip
For detailed information on notifications, please refer to the API documentation.
:::

## Defining the Configuration Processor

The configuration processor is responsible for handling property changes in the current configuration, including *
*addition, deletion, and modification**. The processor **does not maintain state** and generally **does not store
configurations, objects, or properties**. Instead, it processes the configuration based on the attributes of the
passed-in objects.

### Configuration Type

The configuration type refers to the `type` of configuration that the processor needs to handle. It will be injected
into the configuration generation method when the processor instance is created, thus overriding the `type` property
defined in `getConfig`.

:::tip
It is recommended to use PascalCase for configuration type names.
:::

### Command Chain and Runtime

The command chain `commands` refers to the operations and corresponding processing methods encountered during the entire
configuration lifecycle, from creation to destruction. The command chain includes both default and custom commands.

#### Default Commands

Default commands are the operations performed when the defined configuration matches the attribute structure of the real
object. For example:

```js
const config = {
    position: {
        x: 0,
        y: 0,
        z: 0,
    },
};

const mesh = new Mesh();
```

The `position` property structure of the mesh object is consistent with the `config` object. In this case, you can use
default commands, allowing the processor to automatically handle the operation notifications.

#### Custom Commands

Custom commands are needed when the configuration and the real object's attribute structures do not match, or when there
are special processing requirements. Custom commands include:
**Precise Custom Commands** and **Flexible Custom Commands**.

- Precise Custom Commands: These commands target specific attributes through the `commands` chain and assign
  corresponding custom processing methods.

Here is an example of a custom command that restricts the object's position `x` to be within 100 units.

```js
const commands = {
    set: {
        position: {
            x({target, config, key, value}) {
                if (value > 100) {
                    config.position.x = 100;
                } else {
                    target.position.x = value;
                    target.updateMatrixWorld();
                }
            },
        },
    },
};
```

- Flexible Custom Commands: These commands use the `$reg` list in the `commands` chain to perform fuzzy matching and
  apply custom processing methods.

Here is an example of a custom command that automatically updates special properties of the material.

```js
const commands = {
    set: {
        $reg: [
            {
                reg: new RegExp("transparent|sizeAttenuation"),
                handler({target, key, value}) {
                    target[key] = value;
                    target.needsUpdate = true;
                },
            },
        ],
    },
};
```

:::tip

- Flexible commands are executed only when precise commands do not match.

- Flexible custom commands are an array that processes `reg` definitions in the array from top to bottom. As soon as a
  match is found, it is executed, and no further processing is performed.
  :::

### Creation and Destruction

Creation and destruction involve operations corresponding to adding and removing configurations from the configuration
list. This includes the initial construction of the real object and its memory destruction methods.

### Case Demonstration

How should we write the processor for the case study we listed above?

```ts
// processor.ts
import {defineProcessor, EngineSupport} from "@vis-three/middleware";
import {Mesh} from "three";
import {BoardCompiler} from "./compiler";
import {getBoardConfig, BoardConfig} from "./config";

const transColor = function (
    style: "elegant-black" | "light-brown" | "milky-white"
) {
    return style === "elegant-black"
        ? "rgb(0, 0, 0)"
        : style === "light-brown"
            ? "rgb(200, 200, 0)"
            : "rgb(255, 255, 255)";
};

const updateGeometry = function ({config: BoardConfig, target: Mesh}) {
    const newGeometry = new BoxBufferGeometry(
        config.width,
        config.height,
        config.depth
    );
    target.geometry.copy(newGeometry);
    newGeometry.dispose();
};

export default defineProcessor<BoardConfig, Mesh, EngineSupport, BoardCompiler>(
    {
        type: "Board",
        config: getBoardConfig,
        commands: {
            set: {
                width: updateGeometry,
                height: updateGeometry,
                depth: updateGeometry,
                style({target, value}) {
                    target.material.color.setHex(new Color(transColor(value)).getHex());
                },
            },
        },
        create(config, engine) {
            const geometry = new BoxBufferGeometry(
                config.width,
                config.height,
                config.depth
            );

            const material = new MeshBasicMaterial({
                color: transColor(config.style),
            });
            const board = new Mesh(geometry, material);

            board.position.set(
                config.position.x,
                config.position.y,
                config.position.z
            );

            return board;
        },
        dispose(target) {
            target.removeFromParent();
            target.geometry.dispose();
            target.material.dispose();
        },
    }
);
```

:::tip
For related processor APIs, please refer to the API documentation.
:::

## Defining the Module

Once the module components are prepared, you can define and export the module for use.

```ts
//module.ts
import {SUPPORT_LIFE_CYCLE} from "@vis-three/middleware";
import {BoardCompiler} from "./compiler";
import BoardProcessor from "./processor";
import {BoardRule} from "./rule";

export default {
    type: "board",
    object: true,
    compiler: BoardCompiler,
    rule: BoardRule,
    processors: [BoardProcessor],
    lifeOrder: SUPPORT_LIFE_CYCLE.THREE,
};
```

Usage in the Engine.

```ts
// engine.ts
import {defineEngineSupport, generateConfig} from "@vis-three/middleware";
import BoardModule from "./module";

const engine = defineEngineSupport({
    plugins: [
        //...
    ],
    strategy: [
        //...
    ],
    modules: [BoardModule],
});

const board = generateConfig(CONFIGTYPE.BOARD, {
    width: 20,
    position: {
        y: 24
    }
})
```

### Module Type

The `type` of the module is the namespace for the entire module. It is recommended to use **camelCase** for naming.

### Module Lifecycle

The module lifecycle `lifeOrder` corresponds to the loading order of the module in the application configuration list.
For example, with the `geometry`, `material`, and `mesh` modules, since the `mesh` module depends on the other two for
construction, the `lifeOrder` of the `mesh` module should come after the other two.

:::tip
`lifeOrder` is a positive integer that determines the order of module loading, with modules sorted in ascending order
during loading.
:::

## Module Engine Extension

The module engine extension `extend` specifies how the current module will affect the `engine` once added. Here’s an
example:

Suppose we need to directly call an `api` from the `engine` to add a wooden board to the scene. We can extend the module
like this:

```ts
//module.ts
import {SUPPORT_LIFE_CYCLE, EngineSupport} from "@vis-three/middleware";
import {BoardCompiler} from "./compiler";
import BoardProcessor from "./processor";
import {BoardRule} from "./rule";

export interface BoardSupportEngine extends EngineSupport {
    addBoard: () => void;
}

export default {
    type: "board",
    object: true,
    compiler: BoardCompiler,
    rule: BoardRule,
    processors: [BoardProcessor],
    lifeOrder: SUPPORT_LIFE_CYCLE.THREE,
    extend(engine: BoardSupportEngine) {
        engine.addBoard = function () {
            const boardConfig = generateConfig(CONFIGTYPE.BOARD);
            const currentSceneConfig = this.getObjectConfig(this.scene);
            this.applyConfig(boardConfig);
            currentSceneConfig.children.push(boardConfig.vid);
        };
    },
};
```

## Module Processor Extension - Experimental

We have some requirements where, when adding new modules, we want to extend the configuration properties and
corresponding processing methods of other configuration modules. This can be achieved using processor extension
properties.

For example, suppose we have an auxiliary module. After applying the auxiliary module, we want to add an auxiliary
configuration identifier to the corresponding module configuration for easy identification of the related auxiliary
module. However, we do not need to respond to this auxiliary operation.

```ts
export default {
    type: "helper",
    expand: [
        {
            processors: ["Board", "Mesh"],
            command: {
                add: {
                    helper() {
                    },
                },
                set: {
                    helper() {
                    },
                },
            },
        },
    ],
};
```

:::warning
This API is currently experimental.
:::

## Global Debouncer

The global debouncer is a tool that adds additional processing lines. It is used to handle cases where `lifeOrder` alone
cannot distinguish the order of properties and functionalities, serving as an auxiliary tool for scenarios where the
loading time of objects cannot be determined.

When would you use a debouncer? It is useful when you cannot determine the required loading time for a feature or when
the resources or objects required for module attributes do not align with the `lifeOrder` of the modules.

For example, let’s examine how the debouncer works:

Any object that conforms to `three.js`'s `Object3D` has a `children` property. When dividing modules, such
as `mesh`, `line`, `light`, and `scene`, according to `three.js` functionality, any object module can be added to
the `children` object without restrictions. In this case, it is impossible to predict the order of modules for
the `children` property, so a debouncer is needed.

![/image/start/global-anti-shake.png](/image/start/global-anti-shake.png)

### Activation Call

Typically, you will need to make the necessary properties compatible with debouncing during `processor` development.
Using the `children` example above, simply calling `globalAntiShake.exec` will automatically activate the debouncer.

```ts
import {globalAntiShake} from "@vis-three/middleware";

const commands = {
    add: {
        children({target, config, value, engine}) {
            globalAntiShake.exec((finish) => {
                const childrenConfig = engine.getConfigBySymbol(value) as ObjectConfig;
                if (!childrenConfig) {
                    if (finish) {
                        console.warn(` can not foud object config in engine: ${value}`);
                    }
                    return false;
                }

                const childrenObject = engine.compilerManager.getObjectfromModules(
                    OBJECTMODULE,
                    value
                ) as Object3D;

                if (!childrenObject) {
                    if (finish) {
                        console.warn(`can not found this vid in engine: ${value}.`);
                    }
                    return false;
                }

                target.add(childrenObject);

                childrenObject.updateMatrixWorld(true);

                return true;
            });
        },
    },
};
```

### Execution and Automatic Delay

After calling `exec`, `globalAntiShake` will block the execution of methods within it. If the result of the execution
is `true`, the method has completed and will not be processed further.

If the execution returns `false`, `globalAntiShake` will cache the method in a `list` and execute it in order at the
beginning of the next `timer` cycle.

### Retry and Automatic Ordering

During the `timer` cycle, if a method returns `true` on execution, it will be removed from the cached `list`. At the end
of a cycle, the remaining methods will form a new `list` for the next `timer` cycle.

### Failure and Termination

In a `timer` cycle, if at least one method returns `true`, `globalAntiShake` will reorganize the incomplete methods into
the next `timer` cycle.

If all methods return `false` or if all methods have been completed in a `timer` cycle, `globalAntiShake` will end the
loop.

:::tip
For the `AntiShake` API, please refer to the API documentation.
:::

## Compiler Event Bus

`vis-three` adopts a non-intrusive programming approach to minimize changes to `three.js` object methods and properties.
As we know, most `three.js` objects inherit from `three.js`'s internal `EventDispatcher`, which allows for event
publishing directly through `three.js` objects.

However, `vis-three`, especially the internal `middleware` configuration modules, does not use the `three.js` event
dispatcher for events and method dispatching. Why?

- **Potential Event Conflicts**: If plugins, configuration modules, and various runtime methods use the same event
  dispatcher, naming conflicts become a significant issue as module plugin functionalities grow.

- **Cannot Distinguish Runtime from Compile-Time Events**: Using the same event dispatcher for all publish-subscribe
  methods makes it difficult to differentiate between runtime events and compile-time events.

- **Not All `three.js` Objects Inherit Event Dispatcher**: Many `three.js` classes do not inherit the event dispatcher.
  In such cases, what should be done?

The `@vis-three/middleware` module provides an event bus class called `Bus`. This class can publish and subscribe to
various event methods without intruding on the original objects.

The `@vis-three/middleware` module includes a pre-configured compile-time event bus instance called `compilerEvent`,
which handles all publish-subscribe needs for configuration modules, effectively isolating it from the original objects.

### Automatic Event Publishing with Compiler

When inheriting from the default `compiler` class, all operations during the configuration runtime will publish related
events through `compilerEvent`. You just need to subscribe as needed.

Here is an example where any change in the `mesh` material configuration will automatically increment the `x` position
of the mesh by 1.

```ts
import {Mesh} from "three";
import {Bus, COMPILER_EVENT} from "@vis-three/middleware";

export default defineProcessor({
    create(config, engine) {
        const material = engine.getObjectBySymbol(config.material);
        const mesh = new Mesh(undefiend, material);

        Bus.compilerEvent.on(material, COMPILER_EVENT.UPDATE, () => {
            mesh.position.x += 1;
        });

        return mesh;
    },
});
```

:::tip
For events published by the default `compiler`, please refer to the API documentation.
:::

### Custom Event Dispatching

In some cases, you might want to publish custom events within your own configuration modules according to your needs.

```ts
import {Mesh} from "three";
import {Bus, COMPILER_EVENT} from "@vis-three/middleware";

export default defineProcessor({
    commands: {
        set: {
            position: {
                x({target, value}) {
                    Bus.compilerEvent.emit(target, "position-dispatch", {
                        key: "x",
                        value,
                    });
                },
                y({target, value}) {
                    Bus.compilerEvent.emit(target, "position-dispatch", {
                        key: "y",
                        value,
                    });
                },
                z({target, value}) {
                    Bus.compilerEvent.emit(target, "position-dispatch", {
                        key: "z",
                        value,
                    });
                },
            },
        },
    },
});

// Usage
Bus.compilerEvent.on(target, "position-dispatch", (event) => {
    console.log(event);
});
```
